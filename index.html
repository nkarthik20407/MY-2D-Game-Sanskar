<!doctype html>
<!--
Open this file in a browser (desktop or mobile) to play the 2D platformer shooter.
Controls:
 - Desktop: Arrow keys / A D to move, W / Space to jump, K or Ctrl to shoot
 - Mobile: On-screen buttons: left / right / jump / shoot
This is a single-file playable prototype.
-->
<html lang="English">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no" />
<title>2D Adventure Shooter - Playable</title>
<style>
    html,body{height:100%;margin:0;background:#222;display:flex;align-items:center;justify-content:center}
    #gameCanvas{background:linear-gradient(#87CEFA,#cde7ff);display:block;border:4px solid #333;border-radius:6px}
    /* Mobile controls */
    .controls{position:fixed;left:0;right:0;bottom:8px;display:flex;justify-content:space-between;padding:8px;pointer-events:none}
    .btnGroup{display:flex;gap:8px;padding:6px;pointer-events:auto}
    .btn{width:64px;height:64px;border-radius:10px;background:rgba(0,0,0,0.4);color:#fff;display:flex;align-items:center;justify-content:center;font-weight:bold;user-select:none}
    .smallBtn{width:52px;height:52px}
    #hud{position:fixed;left:12px;top:12px;color:#fff;font-family:sans-serif;background:rgba(0,0,0,0.3);padding:8px;border-radius:6px}
    /* start overlay */
    #startOverlay{position:fixed;left:0;top:0;right:0;bottom:0;display:flex;align-items:center;justify-content:center;pointer-events:auto}
    #startBox{background:rgba(0,0,0,0.6);color:#fff;padding:24px;border-radius:10px;text-align:center;font-family:sans-serif}
    #startBox button{margin-top:12px;padding:8px 14px;font-size:16px}
    /* ending overlay */
    #endingOverlay{position:fixed;left:0;top:0;right:0;bottom:0;display:none;align-items:center;justify-content:center;pointer-events:auto}
    #endingBox{background:rgba(0,0,0,0.85);color:#fff;padding:28px;border-radius:12px;text-align:center;font-family:sans-serif;max-width:520px}
    #endingBox button{margin-top:14px;padding:10px 16px;font-size:16px}
</style>
</head>
<body>
<canvas id="gameCanvas" width="960" height="540"></canvas>

<div id="hud">Score: <span id="score">0</span> &nbsp; Lives: <span id="lives">3</span></div>

<!-- simple on-screen buttons for mobile -->
<div class="controls">
    <div class="btnGroup">
        <div id="btnLeft" class="btn">◀</div>
        <div id="btnRight" class="btn">▶</div>
        <div id="btnJump" class="btn smallBtn">▲</div>
    </div>
    <div class="btnGroup">
        <div id="btnShoot" class="btn">✸</div>
    </div>
</div>

<!-- start overlay -->
<div id="startOverlay">
    <div id="startBox">
        <h2>2D Adventure Shooter</h2>
        <div>Arrow keys / A D to move, W / Space to jump, K to shoot</div>
        <button id="startBtn">Start Game</button>
    </div>
</div>

<!-- ending overlay (game over / best ending) -->
<div id="endingOverlay">
    <div id="endingBox">
        <h2 id="endingTitle">Ending</h2>
        <div id="endingMessage" style="margin-top:8px">Your adventure ends...</div>
        <div style="margin-top:10px">Final Score: <span id="finalScore">0</span></div>
        <button id="restartBtn">Play Again</button>
    </div>
</div>

<script>
/* 2D Adventure Shooter - playable single file */

/* Config */
const config = {
    gravity: 0.9,
    friction: 0.85,
    playerSpeed: 4.0,
    jumpForce: -14,
    bulletSpeed: 9,
    enemySpeed: 1.2,
    spawnInterval: 2200, // ms
    canvasWidth: 960,
    canvasHeight: 540
};

/* Canvas and context */
const canvas = document.getElementById('gameCanvas');
const ctx = canvas.getContext('2d');

/* Scale canvas to fit screen while preserving aspect ratio */
function fitCanvas() {
    const margin = 12;
    const w = window.innerWidth - margin*2;
    const h = window.innerHeight - margin*2;
    const aspect = config.canvasWidth / config.canvasHeight;
    let cw = w, ch = cw / aspect;
    if (ch > h) { ch = h; cw = ch * aspect; }
    canvas.style.width = cw + 'px';
    canvas.style.height = ch + 'px';
}
window.addEventListener('resize', fitCanvas);
fitCanvas();

/* Game State */
let keys = {};
let score = 0;
let lives = 3;

/* Player */
const player = {
    x: 80, y: 360, w: 36, h: 48,
    vx: 0, vy: 0,
    onGround: false,
    facing: 1, // 1 right, -1 left
    canShoot: true,
    shootCooldown: 220 // ms
};

/* Arrays */
let bullets = [];
let enemies = [];
let platforms = [];

/* Create a simple level (platforms) */
function setupLevel() {
    platforms = [
        {x: 0, y: 500, w: 960, h: 40},          // ground
        {x: 180, y: 420, w: 140, h: 20},
        {x: 360, y: 360, w: 140, h: 20},
        {x: 560, y: 300, w: 140, h: 20},
        {x: 760, y: 380, w: 160, h: 20},
        {x: 40, y: 300, w: 120, h: 20}
    ];
}
setupLevel();

/* Spawn enemies periodically */
let lastSpawn = 0;
function spawnEnemy() {
    const side = Math.random() < 0.5 ? -1 : 1;
    const ex = side === -1 ? -40 : config.canvasWidth + 40;
    const ey = 440 - Math.random()*160;
    enemies.push({
        x: ex, y: ey, w: 36, h: 36, vx: side === -1 ? config.enemySpeed : -config.enemySpeed,
        hp: 1, patrolling: true
    });
}

/* Input handling */
window.addEventListener('keydown', e => { keys[e.key.toLowerCase()] = true; e.preventDefault(); });
window.addEventListener('keyup', e => { keys[e.key.toLowerCase()] = false; });
function pointerDown(el, name){ el.addEventListener('touchstart', e=>{ e.preventDefault(); keys[name] = true; }); el.addEventListener('mousedown', e=>{ e.preventDefault(); keys[name]=true; }); }
function pointerUp(el, name){ el.addEventListener('touchend', e=>{ e.preventDefault(); keys[name] = false; }); el.addEventListener('mouseup', e=>{ e.preventDefault(); keys[name]=false; }); }
pointerDown(document.getElementById('btnLeft'),'arrowleft'); pointerUp(document.getElementById('btnLeft'),'arrowleft');
pointerDown(document.getElementById('btnRight'),'arrowright'); pointerUp(document.getElementById('btnRight'),'arrowright');
pointerDown(document.getElementById('btnJump'),' '); pointerUp(document.getElementById('btnJump'),' ');
pointerDown(document.getElementById('btnShoot'),'k'); pointerUp(document.getElementById('btnShoot'),'k');

/* HUD update */
const scoreEl = document.getElementById('score');
const livesEl = document.getElementById('lives');
function updateHUD(){ scoreEl.textContent = score; livesEl.textContent = lives; }

/* Simple AABB collision */
function aabb(a,b){
    return !(a.x + a.w < b.x || a.x > b.x + b.w || a.y + a.h < b.y || a.y > b.y + b.h);
}

/* Game loop (starts after player presses Start) */
let lastTime = performance.now();
let running = false;
/* Best score / ending tracking */
let bestScore = parseInt(localStorage.getItem('bestScore') || '0', 10);
const endingOverlay = document.getElementById('endingOverlay');
const endingTitle = document.getElementById('endingTitle');
const endingMessage = document.getElementById('endingMessage');
const finalScoreEl = document.getElementById('finalScore');
const restartBtn = document.getElementById('restartBtn');
function loop(now){
    if (!running) return; // paused until started
    const dt = Math.min(40, now - lastTime); // ms per frame cap
    update(dt);
    render();
    lastTime = now;
    requestAnimationFrame(loop);
}

/* Update */
function update(dt){
    // Input
    const left = keys['arrowleft'] || keys['a'];
    const right = keys['arrowright'] || keys['d'];
    const jump = keys[' '] || keys['w'] || keys['arrowup'];
    const shoot = keys['k'] || keys['control'] || keys['ctrl'];

    // Horizontal movement
    if (left) { player.vx = Math.max(player.vx - 0.6, -config.playerSpeed); player.facing = -1; }
    else if (right) { player.vx = Math.min(player.vx + 0.6, config.playerSpeed); player.facing = 1; }
    else player.vx *= config.friction;

    // Jump
    if (jump && player.onGround) { player.vy = config.jumpForce; player.onGround = false; }

    // Shooting with cooldown
    if (shoot && player.canShoot) {
        spawnBullet();
        player.canShoot = false;
        setTimeout(()=>{ player.canShoot = true; }, player.shootCooldown);
    }

    // Physics
    player.vy += config.gravity * (dt/16);
    player.x += player.vx * (dt/16);
    player.y += player.vy * (dt/16);
    // Boundaries
    if (player.x < 0) player.x = 0;
    if (player.x + player.w > config.canvasWidth) player.x = config.canvasWidth - player.w;
    if (player.y > config.canvasHeight + 200) {
        // fell off - lose life and reset
        lives--;
        updateHUD();
        if (lives <= 0) {
            showEnding();
            return;
        } else resetPlayer();
    }

    // Platform collisions (simple)
    player.onGround = false;
    platforms.forEach(p=>{
        // check vertical collision only when overlapping in x
        if (player.x + player.w > p.x && player.x < p.x + p.w) {
            if (player.y + player.h > p.y && player.y + player.h < p.y + p.h + 20 && player.vy >= 0) {
                // land on platform
                player.y = p.y - player.h;
                player.vy = 0;
                player.onGround = true;
            }
        }
    });

    // Bullets update
    bullets.forEach((b,i)=>{
        b.x += b.vx * (dt/16);
        // remove offscreen
        if (b.x < -40 || b.x > config.canvasWidth + 40) bullets.splice(i,1);
    });

    // Enemies update
    enemies.forEach((e,ei)=>{
        e.x += e.vx * (dt/16);
        // simple platform ground collision for enemies
        platforms.forEach(p=>{
            if (e.x + e.w > p.x && e.x < p.x + p.w) {
                // keep y on top of nearest platform (simple)
                if (e.y + e.h > p.y && e.y + e.h < p.y + p.h + 30) { e.y = p.y - e.h; e.vy = 0; }
            }
        });

        // Bounce from edges
        if (e.x < -80 || e.x > config.canvasWidth + 80) enemies.splice(ei,1);
    });

    // Bullet - enemy collisions
    bullets.forEach((b,bi)=>{
        enemies.forEach((e,ei)=>{
            if (aabb(b,e)) {
                enemies.splice(ei,1);
                bullets.splice(bi,1);
                score += 10;
                updateHUD();
            }
        });
    });

    // Player - enemy collisions
    enemies.forEach((e,ei)=>{
        if (aabb(player,e)) {
            // if player is descending (stomp) kill enemy
            if (player.vy > 2) {
                enemies.splice(ei,1);
                player.vy = config.jumpForce/2; // bounce up
                score += 15;
                updateHUD();
            } else {
                // take damage
                enemies.splice(ei,1);
                lives--;
                updateHUD();
                if (lives <= 0) { showEnding(); }
                else resetPlayer();
            }
        }
    });

    // Spawn enemies over time
    if (performance.now() - lastSpawn > config.spawnInterval) { spawnEnemy(); lastSpawn = performance.now(); }
}

/* Render */
function render(){
    // clear (logical canvas size)
    ctx.clearRect(0,0,config.canvasWidth,config.canvasHeight);

    // background gradient (sky already via CSS, but draw simple)
    // draw sun
    ctx.fillStyle = '#FFD54A';
    ctx.beginPath(); ctx.arc(860,80,38,0,Math.PI*2); ctx.fill();

    // Draw platforms
    platforms.forEach(p=>{
        ctx.fillStyle = '#6b4f2b';
        roundRect(ctx, p.x, p.y, p.w, p.h, 6);
        // grass top
        ctx.fillStyle = '#2ecc71';
        ctx.fillRect(p.x, p.y-6, Math.min(p.w,40), 6);
    });

    // Draw player
    ctx.save();
    ctx.translate(player.x + player.w/2, player.y + player.h/2);
    if (player.facing < 0) ctx.scale(-1,1);
    ctx.fillStyle = '#e74c3c';
    ctx.fillRect(-player.w/2, -player.h/2, player.w, player.h);
    // simple eye
    ctx.fillStyle = '#fff';
    ctx.fillRect(4, -8, 6, 6);
    ctx.restore();

    // Draw bullets
    ctx.fillStyle = '#ffeb3b';
    bullets.forEach(b=>{
        ctx.beginPath();
        ctx.arc(b.x + b.w/2, b.y + b.h/2, b.w/2, 0, Math.PI*2);
        ctx.fill();
    });

    // Draw enemies
    enemies.forEach(e=>{
        ctx.fillStyle = '#34495e';
        ctx.fillRect(e.x, e.y, e.w, e.h);
        // eye
        ctx.fillStyle = '#fff';
        ctx.fillRect(e.x + 8, e.y + 8, 6,6);
    });

    // Draw ground shadows / aesthetic
    // debug info (small)
    ctx.fillStyle = 'rgba(0,0,0,0.2)';
    ctx.font = '12px sans-serif';
    ctx.fillText('Use arrow keys or A/D, W/Space to jump, K to shoot. Mobile buttons available.', 10, 20);
}

/* Utilities */
function roundRect(ctx,x,y,w,h,r){
    ctx.beginPath();
    ctx.moveTo(x+r,y);
    ctx.arcTo(x+w,y,x+w,y+h,r);
    ctx.arcTo(x+w,y+h,x,y+h,r);
    ctx.arcTo(x,y+h,x,y,r);
    ctx.arcTo(x,y,x+w,y,r);
    ctx.closePath();
    ctx.fill();
}

/* Spawn bullet */
function spawnBullet() {
    bullets.push({
        x: player.x + player.w/2 + player.facing*20,
        y: player.y + player.h/2 - 6,
        w: 12, h: 12,
        vx: player.facing * config.bulletSpeed
    });
}

/* Reset player */
function resetPlayer() {
    player.x = 80; player.y = 360; player.vx = 0; player.vy = 0; player.onGround = false;
}

/* Reset game */
function resetGame() {
    score = 0;
    lives = 3;
    bullets = [];
    enemies = [];
    updateHUD();
    resetPlayer();
    // show start overlay for restart
    document.getElementById('startOverlay').style.display = 'flex';
    running = false;
}

/* initialize HUD */
updateHUD();

/* touch: prevent scrolling on controls */
document.body.addEventListener('touchmove', function(e){
    // allow moving inside canvas but block whole page scroll
    if (e.target.closest('.btn') || e.target === canvas) e.preventDefault();
}, {passive:false});

/* Start button */
document.getElementById('startBtn').addEventListener('click', ()=>{
    // remove start overlay and begin without showing it again
    const overlay = document.getElementById('startOverlay');
    overlay.style.display = 'none';
    // fully initialize game state and start loop
    score = 0; lives = 3; bullets = []; enemies = []; updateHUD(); resetPlayer();
    running = true;
    lastTime = performance.now();
    requestAnimationFrame(loop);
});

/* Also allow clicking canvas to start */
canvas.addEventListener('click', ()=>{ if (!running) document.getElementById('startBtn').click(); });

/* Show ending overlay (game over or best ending) */
function showEnding() {
    running = false;
    finalScoreEl.textContent = score;
    // determine if this is the best ending
    if (score > bestScore) {
        bestScore = score;
        localStorage.setItem('bestScore', String(bestScore));
        endingTitle.textContent = 'Best Ending!';
        endingMessage.textContent = 'You achieved a new high score — the BEST ending!';
    } else {
        endingTitle.textContent = 'Game Over';
        endingMessage.textContent = 'Good try — keep going to reach the Best Ending.';
    }
    endingOverlay.style.display = 'flex';
}

/* Restart button closes ending and restarts game immediately (no start overlay)
   This gives a smooth play-again experience. */
restartBtn.addEventListener('click', ()=>{
    endingOverlay.style.display = 'none';
    // reset and start again without showing start overlay
    score = 0; lives = 3; bullets = []; enemies = []; updateHUD(); resetPlayer();
    running = true; lastTime = performance.now(); requestAnimationFrame(loop);
});

/* Replace previous reset -> show overlay logic: when lives hits zero, show ending */

</script>
</body>
</html>
